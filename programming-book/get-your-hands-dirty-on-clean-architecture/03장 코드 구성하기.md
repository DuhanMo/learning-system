## 3장. 코드 구성하기

### 1. 계층으로 구성하기
- web, domain, persistence를 두는 경우
- 최적의 구조가 아닌 세가지 이유
  1. 애플리케이션의 기능 조각이나 특성을 구분 짓는 패키지 경계가 없다
  2. 애플리케이션이 어떤 유스케이스들을 제공하는지 파악할 수 없다
  3. 패키지 구조를 통해서 우리가 목표로 하는 아키텍처를 파악할 수 없다

### 2. 기능으로 구성하기
- 계좌와 관련된 모든 코드를 최상위 account 패키지에 삽입한 경우
- 아키텍처의 가시성을 떨어뜨린다
  - 어댑터를 나타내는 패키지 없음
  - 인커핑 포트, 아웃고잉 포트 확인 불가능

### 3. 아키텍처적으로 표현력 있는 패키지 구조로 구성하기
- 엔티티, 유스케이스, 인커밍/아웃고잉 포트, 인커밍/아웃고잉 어댑터로 구성한 경우
- 최상위는 Account 관련 유스케이스를 구현한 모듈임을 나타내는 account가 있다
- 도메인 모델이 속한 domain 패키지가 있다
- 도메인 모델을 둘러싼 서비스 계층을 포함하는 application 패키지가 있다
  - 인커밍 포트가 존재하고, 그 구현체가 존재한다
  - 아웃고잉 포트가 존재한다. (그 구현체는 아웃고잉 어댑터가 구현한다)
- 인커밍 포트를 호출하는 인커밍 어댑터, 아웃고잉 포트를 구현하는 아웃고잉 어댑터가 있다
- 이 구조의 장점
  1. 데이터베이스가 정해지지 않아 key-value store로 간단하게 개발 후 DB가 정해지면 바로 교체할 수 있다
  2. DDD 개념에 직접적으로 대응시킬 수 있다
    - account 같은 상위 레벨 패키지는 다른 바운디드 컨텍스트와 통신할 전용 진입점과 출구를 포함하는 바운디드 컨텍스트이다

### 의존성 주입의 역할
- 클린 아키텍처의 **가장 본질적인 요건**: **애플리케이션 계층이 인커밍/아웃고잉 어댑터 의존성을 갖지 않는 것**
- 애플리케이션 계층에 인터페이스를 만들고 어댑터에 해당 인터페이스를 구현한다
- 그 의존성 주입은 JVM 진영에선 스프링 프레임워크가 한다


#### 단어정리
**소리치는 아키텍처**
- 로버트 C.마틴이 제안한 아키텍처 철학 중 하나
- 비즈니스 도메인이 최우선: 패키지 구조와 코드에서 프레임워크가 아니라 비즈니스 개념이 먼저 보여야 한다
- 프레임워크 독립성: Spring, Hibernate 등 특정 기술에 종속되지 않고, 핵심 로직이 독립적으로 유지되어야 한다
- 유스케이스 중심 설계: 서비스 로직은 도메인별 Use Case로 명확히 분리하고, 비즈니스 개념을 직관적으로 표현해야 한다

**아키텍처-코드 갭**
- 마틴 파울러가 언급한 개념
- 설계 문서나 다이어그램에서는 잘 정의된 아키텍처가 코드에서는 제대로 반영되지 않는 경우가 많다
- 예를 들어, "레이어드 아키텍처"를 따른다고 하지만 실제 코드에서는 서비스 계층이 비대해지고, 의존성이 엉켜버리는 경우가 있다
- 이를 줄이려면 코드 구조가 아키텍처 원칙을 자연스럽게 반영하도록 유도하는 설계가 필요하다