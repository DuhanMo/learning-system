## 4장. 유스케이스 구현하기

### 유스케이스 둘러보기
- 유스케이스가 따르는 단계
  1. 입력을 받는다 
  2. 비즈니스 규칙을 검증한다 
  3. 모델 상태를 조작한다 
  4. 출력을 반환한다
- 유스케이스는 비즈니스 규칙을 검증해야 한다
- 유스케이스는 어떤 방법으로든 모델의 상태를 변경한다 

### 입력 유효성 검증
- 입력모델 (Command) 객체 내부에서 입력 유효성을 검증해야한다
- 입력모델에 있는 유효섬 검증 코드는 잘못된 입력을 막는 유스케이스 보호막 역할이다

### 생성자의 힘
- 빌더패턴을 사용하게 되면 컴파일 단계에서 예외를 잡지 않기 때문에 예외가 발생할 수 있다
- 생성자를 직접 사용하면 컴파일에러를 통해 필드를 누락, 추가할 때마다 예외 방지할 수 있다 

### 유스케이스마다 다른 입력 모델
- 계좌 생성과 계좌 업데이트는 모두 거의 같은 계좌 상세정보가 필요하다 
- 그렇다고 같은 입력 모델을 사용하면 계좌 업데이트 시 필요한 id 식별자가 계좌 생성 모델에서는 null로 들어가야 한다
  - 이것은 code smell 이다
- 각 유스케이스 전용 입력 모델을 명확하게 만들어야 한다

### 비즈니스 규칙 검증하기
- 입력 유효성 검증과 비즈니스 규칙 검증을 구분짓는 실용적인 구분점
  - 비즈니스 규칙 검증은 도메인 모델의 현재 상태에 접근해야 한다
  - 반면, 입력 유효성 검증은 도메인 모델의 현재 상테에 접근할 필요가 없다
- 입력 유효성 검증은 구문상의 유효성을 검증하는 것이다
- 비즈니스 규칙 검증은 의미적인 유효성을 검증하는 것이다
- ex)
  - 출금 계좌는 초과 출금 되어서는 안된다 -> 모델의 현재 상태에 접근해야 하기 때문에 비즈니스 규칙  
  - 송금 되는 금액은 0보다 커야한다 -> 모델의 현재 상태에 접근하지 않아도 되기 때문에 입력 유효성 검증

### 풍부한 도메인 모델 vs 빈약한 도메인 모델
- **풍부한** 도메인 모델은 애플리케이션 코어에 있는 엔티티에 가능한한 많은 도메인 로직이 구현된다
- 비즈니스 규칙에 맞는 유효한 변경만을 허용한다
- **빈약한** 도메인 모델은 도메인 로직이 유스케이스에 구현되어 있다
- 풍푸함이 엔티티 대신 유스케이스에 존재한다 

### 유스케이스마다 다른 출력 모델
- 출력도 가능하면 각 유스케이스에 맞게 구체적이어야 한다 
- 출력은 호출자에게 꼭 필요한 데이터만 들고 있어야 한다 
- 유스케이스들 간 출력 모델을 공유하면 유스케이스들도 강하게 결합하게 되므로 좋지 않다

### 읽기 전용 유스케이스
- 읽기 전용 작업을 유스케이스라고 하는 것은 맞지 않다 
- 쿼리를 위한 인커밍 전용 포트를 만들고 쿼리 서비스에 구현한다
- CQS(Command-Query Separation) 또는 CQRS(Command-Query Responsibility Segregation) 같은 개념과 잘 맞는다 