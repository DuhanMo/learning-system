# 3장 함수 정의와 호출
## 3.1 코틀린에서 컬렉션 만들기
- 코틀린에서 자바 함수를 호출할 때 서로 변환할 필요 없음
    - 코틀린 컬렉션과 자바 컬렉션은 똑같은 클래스

## 3.2 함수를 호출하기 쉽게 만들기
### 3.2.1 이름 붙인 인자 (named argument)
```kotlin
joinToString(collection, separator = ",", prefix = " ", postfix = ".")
```
- 함수 호출의 가독성을 증대시킨다.
- 이름 붙인 인자를 쓴다면 파라미터 모두에 적용하자.
- 자바로 작성한 코드 호출 시 `named argument` 를 사용할 수 없다.

### 3.2.2 디폴트 파라미터 값 (default parameter)
```kotlin
fun <T> joinToString(
	collection: Colleaction<T>,
	separator: String = ", ", // d.p
	prefix: String = "", // d.p
	postfix: String = "", // d.p
)
```
- 함수 정의부에서 사용하기 때문에 디폴트 값 변경 후 컴파일 하면 호출하는 쪽에 인자설정하지 않은 값들은 모두 디폴트 값을 적용 받음
- 자바는 `default parameter` 개념이 없어 코틀린함수를 호출할 때 모든 인자를 명시해야함
    - `@JvmOverloads` 를 함수에 추가하면 맨 마지막 파라미터로부터 하나씩 파라미터를 생략한 오버로딩 메서드를 만들어줌

### 3.2.3 최상위 함수와 프로퍼티
- 함수를 소스파일의 최상위 수준, 모든 다른 클래스에 밖에 위치시킬 수 있다.
    - 무의미한 클래스파일을 없앨 수 있다.
- 코틀린 컴파일러가 생성하는 클래스 이름은 최상위 함수의 파일명과 대응. (파일명Kt 형태로 생성)

**최상위 프로퍼티**
- 흔하지 않지만 만들 수 있다.

const 변경자를 추가하면 프로퍼티가 public static final 필드로 컴파일된다.

## 3.3 확장 함수와 확장 프로퍼티
```kotlin
fun String.lastChar(): Char = this.get(this.length - 1)
```
- 다른 JVM 언어로 작성된 클래스도 확장할 수 있다.
- 확장함수 본문에서 this를 생략가능하다.
- 클래스 내부의 private, protected 멤버를 사용할 수 없다.

### 3.3.1 임포트와 확장 함수
- `as` 키워드를 사용하여 임포트한 클래스나 함수를 다른 이름으로 부를 수 있다.
    - `import strings.lastChar as last`
    - `val c = "Kotlin".last()`
- 코틀린 문법상 확장 함수는 반드시 짧은 이름을 써야한다.

### 3.3.2 자바에서 확장 함수 호출
- 내부적으로 확장 함수는 수신 객체를 첫 번째 인자로 받는 정적 메서드이다.

### 3.3.3 확장 함수로 유틸리티 함수 정의
### 3.3.4 확장함수는 오버라이드 할 수 없다.
- 동적으로 호출될 대상 메서드를 결정하는 방식을 **동적 디스패치** 라고 한다.
- 컴파일 시점에 알려진 변수 타입에 따라 정해진 메서드를 호출하는 방식을 **정적 디스패치** 라고 한다.
- 부모 클래스의 확장함수를 만들고 자식 클래스의 확장함수를 동일한 시그니처로 만든다면 부모 클래스타입의 확장함수를 호출해도 자식클래스가 아닌 부모클래스의 확장함수가 호출된다.
- 멤버함수와 확장함수의 시그니처가 같다면 멤버함수가 호출된다.

### 3.3.5 확장 프로퍼티
- 확장 프로퍼티는 백킹필드가 없어 기본 게터 구현을 제공할 수 없으므로 최소한의 게터는 정의해야 한다.

## 3.4 컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원
### 3.4.1 자바 컬렉션 API 확장
- `last` `max` 등은 모두 확장 함수이다.

### 3.4.2 가변 인자 함수
```kotlin
val list = listOf(2, 3, 5, 7, 11)
fun listOf<T>(vararg values: T): List<T> {...}
```

- 파라미터 앞에 vararg 변경자를 붙인다.
- 배열의 원소들을 가변길이 인자로 넘길 땐 `spread` 연산자를 사용하면 된다.
```kotlin
fun main(args: Array<String>) {
	val list = listOf("args: ", *args)
	println(list)
}
```

#### 3.4.3 값의 쌍 다루기 중위 호출과 구조분해 선언
- 인자가 하나뿐인 일반메서드or확장 함수 앞에 infix 변경자를 선언하면 된다.
- 두 변수를 즉시 초기화 할 수 있는 기능을 구조 분해 선언이라 한다.
    - `val (number ,name) = 1 to "one"`

## 3.5 문자열과 정규식 다루기
### 3.5.1 문자열 나누기
- 자바 split 메서드는 문자열이 들어오면 정규식으로 해석된다. ("." 이 들어오면 어떤 문자열을 split 해도 빈배열을 응답한다.)
- 코틀린 split 메서드는 Regex 타입의 값을 받는다.
- 코틀린은 여러 문자를 받을 수 있는 확장 함수도 제공한다.

### 3.5.2 정규식과 3중 따옴표로 묶은 문자열
- 3중 따옴표 문자열은 역슬래시를 포함한 어떤 문자도 이스케이프 할 필요가 없다.

### 3.5.3 여러 줄 3중 따옴표 문자열
- 복잡하게 이스케이프를 쓰거나 외부 파일에서 텍스트를 불러올 필요가 없다.
- `timMargin` 확장 함수등을 사용하여 더 보기좋게 할 수 있다.

## 3.6 코드 다듬기: 로컬 함수와 확장
- 함수에서 추출한 함수를 원함수에 포함시킬 수 있다.
