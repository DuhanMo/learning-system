# 8장 고차 함수: 파라미터와 반환 값으로 람다 사용
- 람다를 인자로 받거나 반환하는 함수인 고차 함수를 만드는 방법을 다룬다
- 람다를 사용하며 생기는 부가 비용을 없애고 람다 내에서 더 유연하게 흐름을 제어할 수 있는 인라인 함수에 대해 배운다

## 8.1 고차 함수 정의
- **고차 함수**: 람다나 함수 참조를 인자로 넘길 수 있거나 람다나 함수 참조를 반환 하는 함수

### 8.1.1 함수 타입
```kotlin
val sum: (Int, Int) -> Int = { x, y -> x + y }                // int 파라미터를 2개 받아 int 값을 반환
val action: () -> Unit = { println(42) }                      // 아무 파라미터도 받지 않고 아무 값도 반환하지 않음
```
**함수 타입을 정의하는 방법**
```kotlin
(Int, String) -> Unit
  파라미터 타입     반환타입
```
- 함수 타입을 선언할 때는 반환 타입을 반드시 명시해야 한다
- 변수 타입을 함수 타입으로 지정하면 람다 식 안에서 굳이 파라미터 타입을 적을 필요가 없다
- 널이 될 수 있는 함수 타입 변수를 정의하기 위해선 함수 타입을 괄호로 감싸고 그 뒤에 물음표를 붙여야 한다

### 8.1.2 인자로 받은 함수 호출
- 인자로 받은 함수를 호출하는 구문은 일반함수와 동일하다
  - 함수 이름 뒤 괄호를 붙이고 괄호 안에 원하는 인자를 콤마로 구분해 넣는 것
```kotlin
fun twoAndThree(operation: (Int, Int) -> Int) {
    val result = operation(2, 3)
    println("The result is $result")
}
twoAndThree { a, b -> a + b }
// The result is 5
twoAndThree { a, b -> a * b }
// The result is 6
```
**filter 함수를 단순하게 만든 버전**
```kotlin
fun String.filter(predicate: (Char) -> Boolean): String { 
    val sb = StringBuilder()
        for (index in indices) {
            val element = get(index)
            if (predicate(element)) {
                sb.append(element)
            }
        }
    return sb.toString()
}
println("ab1c".filter { it in 'a'..'z' })
// abc
```

### 8.1.3 자바에서 코틀린 함수 타입 사용
```kotlin
// 코틀린
fun processTheAnswer(f: (Int) -> Int) {
    println(f(42))
}
```
```java
// 자바
processTheAnswer(number -> number + 1);
```

### 8.1.4 디폴트 파라미터로 지정한 함수 타입 파라미터나 널이 될 수 있는 함수 타입 파라미터
**하드 코딩을 통해 toString 사용 관례를 따르는 joinToString**
```kotlin
fun <T> Collection<T>.joinToString(
    separator: String = ", ",
    prefix: String = "",
    postfix: String = "",
): String {
    val result = StringBuilder(prefix)
    for ((index, element) in this.withIndex()) {
        if (index > 0) result.append(separator)
        result.append(element) // 기본 toString 메서드 사용
    }
    result.append(postfix)
    return result.toString()
}
```
**함수 타입의 파라미터에 디폴트 값 지정하기**
```kotlin
fun <T> Collection<T>.joinToString(
    separator: String = ", ",
    prefix: String = "",
    postfix: String = "",
    transform: (T) -> String = { it.toString() }, // 함수 타입 파라미터를 선언하면서 람다를 디폴트 값으로 지정
): String {
    val result = StringBuilder(prefix)
    for ((index, element) in this.withIndex()) {
        if (index > 0) result.append(separator)
        result.append(transform(element)) // transform 파라미터로 받은 함수를 호출 
    }
    result.append(postfix)
    return result.toString()
}
```
**널이 될 수 있는 함수 타입 파라미터 사용하기**
```kotlin
fun <T> Collection<T>.joinToString(
    separator: String = ", ",
    prefix: String = "",
    postfix: String = "",
    transform: ((T) -> String)? = null, // 널이 될 수 있는 함수 타입의 파라미터 
): String {
    val result = StringBuilder(prefix)
    for ((index, element) in this.withIndex()) {
        if (index > 0) result.append(separator)
        val str = transform?.invoke(element) ?: element.toString() // 세이프콜을 사용해 함수 호출
        result.append(str) 
    }
    result.append(postfix)
    return result.toString()
}
```

### 8.1.5 함수를 함수에서 반환
**함수를 반환하는 함수 정의**
```kotlin
enum class Delivery { STANDARD, EXPEDITED }

class Order(val itemCount: Int)

fun getShippingCostCalculator(delivery: Delivery): (Order) -> Double {
    if (delivery == Delivery.EXPEDITED) {
        return { order -> 6 + 2.1 * order.itemCount }
    }
    return { order -> 1.2 * order.itemCount }
}

val calculator = getShippingCostCalculator(Delivery.EXPEDITED)
println("Shipping costs ${calculator(Order(3))}")
// Shipping costs 12.3
```

### 8.1.6 람다를 활용한 중복 제거
**웹사이트 방문 기록 예**
```kotlin
data class SiteVisit(
    val path: String,
    val duration: Double,
    val os: OS
)

enum class OS { WINDOWS, LINUX, MAC, IOS, ANDROID }

val log = listOf(
    SiteVisit("/", 34.0, OS.WINDOWS),
    SiteVisit("/", 22.0, OS.MAC),
    SiteVisit("/login", 12.0, OS.WINDOWS),
    SiteVisit("/signup", 8.0, OS.IOS),
    SiteVisit("/", 16.3, OS.ANDROID),
)

// 사이트 방문 데이터 하드 코딩한 필터 사용하여 분석
val averageWindowsDuration = log
  .filter { it.os == OS.WINDOWS }
  .map(SiteVisit::duration)
  .average()
println(averageWindowsDuration)
// 23.0
```
**일반 함수로 중복 제거**
```kotlin
fun List<SiteVisit>.averageDurationFor(os: OS) = 
    filter { it.os == os }.map(SiteVisit::duration).average()
println(log.averageDurationFor(OS.WINDOWS))
// 23.0
println(log.averageDurationFor(OS.MAC))
// 22.0
```
**복잡하게 하드 코딩한 필터 사용하여 데이터 분석**
```kotlin
val averageMobileDuration = log
    .filter { it.os in setOf(OS.IOS, OS.ANDROID) }
    .map(SiteVisit::duration)
    .average()

println(averageMobileDuration)
//12.15
```
**고차 함수를 사용해 중복 제거**
```kotlin
fun List<SiteVisit>.averageDurationFor(predicate: (SiteVisit) -> Boolean) =
    filter(predicate).map(SiteVisit::duration).averate()

println(log.averageDurationFor { it.os == OS.IOS && it.path == "/signup" })
// 8.0
```
- 전략패턴 관련
  - 함수 타입을 언어가 지원하면 일반 함수 타입을 사용해 전략을 표현할 수 있고 경우에 따라 다른 람다식을 넘겨 여러 전략을 전달할 수 있다