# 커머스 백엔드 실무 정리

## 1. 상품 목록 API 설계
- 목록 API는 **클라이언트와 맞붙는 계약 영역**이므로 요구사항 협의를 선행하고 문서화한다.
- 상품과 카테고리 모델은 결합도를 낮추고, 필요한 경우 **격벽을 세워 독립 배포**를 고려한다.
- 실제 비즈니스 용어와 지표를 이해한 뒤 도메인 모델에 반영해야 이후 기능 확장 비용이 줄어든다.
- 앱·웹 등 소비 채널별로 요청 패턴과 버전 전략을 정의해 호환성을 관리한다.

### 페이징 전략
- 페이징은 기본 UX이므로 커서 기반/오프셋 기반 중 트래픽 특성에 맞는 방식을 결정한다.
- 필터·정렬 조건이 늘어나더라도 API가 느려지지 않도록 인덱스와 쿼리를 함께 설계한다.

## 2. 상품 상세 API 기획 포인트
- 상세 API에는 리뷰, 쿠폰, 좋아요, Q&A 등 **다양한 개념이 혼재**할 수 있으므로 의존도를 통제한다.
- 변화 가능성이 높은 컴포넌트와 아닌 컴포넌트를 분리해 재사용성을 높이고, 필요한 경우 v1을 세분화한다.
- 응답 필드는 가능한 순수 데이터를 유지하고, 계산 값이 필요하면 명시적으로 파생 필드임을 드러낸다.

## 3. 리뷰 도메인 설계
- 리뷰 서비스는 하나의 플랫폼을 구성할 수 있을 만큼 중요하므로 **응집력 높은 모듈**로 분리한다.
- 여러 대상 타입(상품, 이벤트 등)에 리뷰를 작성할 수 있게 확장성을 확보한다.
- 수정/삭제 정책(예: 작성 후 일정 시간 지나면 수정 제한)을 명확히 정의하고 중앙화된 정책 로직으로 관리한다.
- 리뷰 노화에 따른 신뢰도 저하를 감안하여 정렬·가중치 정책을 설계한다.

## 4. Q&A 기능 체크리스트
- 누가 질문·답변을 작성할 수 있는지 권한 체계를 우선 정의한다.
- 단발성인지, 대댓글처럼 연속 스레드를 허용할지에 따라 스키마와 API 구성이 달라진다.
- UI 흐름(목록과 상세를 나눌지, 한 번에 내려줄지)에 따라 API 분리 전략과 성능 최적화 방안을 마련한다.
- 운영자의 응답 SLA, 자동 알림 여부 등 서비스 특성을 반영한 기획이 필요하다.

## 5. 찜/좋아요 기능 운영
- 상품 정보 변경 시 찜 데이터와의 일관성을 어떻게 맞출지(실시간 이벤트, 어드민 제어, 배치)를 결정한다.
- 멱등성을 보장해 중복 요청에서도 상태가 꼬이지 않도록 한다.
- 일반 운영 상황에서는 하드 삭제 대신 **소프트 삭제**를 기본으로 해 복구 가능성을 확보한다.

## 6. 포인트 정책 설계
- 적립/차감 트리거: 결제 사용·적립, 리뷰 작성, 프로모션 등 발생 요건을 카테고리별로 구분한다.
- 만료·유효기간이 있는지, 포인트 한도와 최소 사용 단위가 있는지 사전 정의한다.
- 포인트 소모 순서(선입선출 vs 단일 통)와 주문 취소 시 원복 규칙을 설정한다.
- 관리자 승인 필요 여부, 리뷰 여러 건 작성 시 중복 적립 허용 여부 등을 명문화한다.
- 적립금을 재화로 취급하고, **낙관적 락(optimistic lock)** 등 동시성 제어를 적용한다.
- 리뷰 삭제 시 적립 포인트 회수 정책 등 예외 시나리오를 함께 정의한다.

## 7. 쿠폰 정책 설계
- 만료 시점을 **쿠폰 자체 만료**와 **발급 후 유효 기간**으로 구분하고, 만료 연장·복원 정책을 기획자와 합의한다.
- 적용 범위를 상품/카테고리/주문 단위로 세분화해 제약 조건(최소 주문 금액, 사용 채널, 자동 적용 여부)을 명확히 한다.
- 주문 취소·환불 시 쿠폰을 어떻게 복구할지(자동 반환, 수동 승인 등)를 정의하고 예외 프로세스를 마련한다.
- `소유 쿠폰(Own Coupon)`은 `마스터 쿠폰(Master Coupon)` 스냅샷을 보유하도록 설계해, 이후 조건 변경에도 일관된 정산이 가능하게 한다. -> 마스터 쿠폰 수정 시 소유 쿠폰을 일괄 변경하게끔 기획이 나온다면 소유 쿠폰을 수정한다.
- 실무에서는 기획 변경이 잦으므로 요구사항을 **수시 검증**하고, 쿠폰 정책서와 연동된 테스트 케이스를 유지한다.

## 8. 장바구니 도메인 운영
- 상품 정보가 변할 때 장바구니 아이템을 어떻게 동기화할지(즉시 무효화, 배치 정리, 사용자 알림)를 결정한다.
- 수량 조정·금액 계산은 서버에서 최종 검증해 클라이언트 조작 가능성을 차단한다.
- 주문 완료 시 장바구니를 비울지, 최근본 목록처럼 유지할지 UX와 연계해 결정한다.
- 장바구니는 논리적 개념이고 실제 저장소에는 `CartItem(상품 식별자 + 수량)` 단위로 보관하며, API 응답은 `CartResponse` DTO로 묶어 전달한다.

## 9. 주문 흐름 설계
- 다중 쿠폰·포인트 사용 가능 여부, 적용 우선순위, 최소 금액 조건을 정책화한다.
- 서로 다른 셀러 상품을 묶는 주문을 허용할지, 배송비·정산을 어떻게 분기할지 결정한다.
- 재고 차감 시점(주문 생성, 결제 승인, 픽킹 등)을 명확히 하고, 중복 주문 방지를 위한 락 전략을 설계한다.
- 주문 레코드는 **요청 시 즉시 생성**해도 되고, 결제 직전 생성해도 되지만 선택한 시나리오에 맞는 정리 로직이 필요하다.
- 상품 상세 → 주문, 장바구니 → 주문 등 플로우를 단일 프로세스로 수렴해 코드 상 불필요한 `null` 처리를 줄인다.

### 금액/할인 처리 원칙
- 모든 금액 계산은 서버에서 수행하고, 클라이언트는 별도 표시 목적으로만 사용한다.
- 노출용 주문번호를 별도로 생성해 내부 식별자와 분리한다.
- 쿠폰·포인트 적용 내역은 주문 라인에 스냅샷 형태로 저장해 감사 가능성을 확보한다.

## 10. 결제 연동 전략
- 결제는 외부 PG와 통신하므로 연결/읽기 타임아웃, 재시도, 장애 대응 시나리오를 선제적으로 준비한다.
- 결제 실패 유형(PG 장애, 사용자 취소, 한도 초과 등)을 구분해 각각의 메시지와 후처리를 정의한다.
- 결제 성공 이후에는 예외를 피하고, 장애 발생 시 **결제 내역과 주문 상태 간 정합성**을 우선적으로 복구한다.
- 결제 실패 콜백은 상태 변경 대신 히스토리를 남겨 추후 재처리나 대시보드에서 확인할 수 있게 한다.
- 주문과 결제는 느슨하게 결합하고, 쿠폰·포인트는 결제 단위로 묶어야 주문 도메인이 불필요하게 복잡해지지 않는다.

## 11. 주문 취소 및 환불
- 취소 도메인의 중심은 **주문**이며, 결제 취소는 파생 작업으로 본다.
- 결제 엔티티에 취소 상태를 추가하기보다는 별도의 취소 엔티티를 생성해 불변(append-only) 데이터를 유지한다.
- 취소 엔티티에는 취소 사유, 금액, 결제 연동 결과를 기록하고 주문 상태 전이를 일관되게 처리한다.
- 취소 빈도가 높지 않더라도, 과거 건 조회·상계 처리를 고려해 정렬·검색 키를 설계한다.

## 12. 정산 및 배치 운영
- 정산 기준(결제 승인 시점, 배송 완료 시점 등)과 가맹점 지급 일정을 정책 문서로 명확히 정의한다.
- 이미 정산된 건이 취소되면 다음 정산 주기에 **상계(Offset)** 처리해 가맹점과의 금액 정합성을 유지한다.
- 가맹점(Merchant)과 상품 매핑 테이블을 두고, 정산 대상 데이터를 별도로 적재해 감사 추적을 가능하게 한다.
- `정산 대상 적재 배치 → 정산 계산 배치 → 정산 입금 배치`처럼 단계별 배치로 분리하면 장애 분석과 롤백이 쉬워진다.
- 정산 로직은 수수료율 등 정책 변경이 잦으므로 테스트 시나리오와 운영 대시보드를 함께 구축한다.
