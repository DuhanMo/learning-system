# 데이터베이스 인덱스 정리: 단일 인덱스 vs 복합 인덱스

단일 인덱스와 복합 인덱스는 쿼리 패턴에 따라 적절히 선택해야 한다.

## 단일 인덱스 vs 복합 인덱스
- **단일 인덱스**: 한 컬럼에만 적용되는 인덱스. 단일 조건 검색(예: `WHERE column1 = 'value'`)이 자주 사용될 때 적합하다
- **복합 인덱스**: 두 개 이상의 컬럼을 조합한 인덱스. 복합 조건 검색(예: `WHERE column1 = 'value' AND column2 > 10`)이 빈번할 때 유리하다

**사용 예시**:
- 단일 조건 검색이 많다면: `INDEX(column1)`
- 복합 조건 검색이 많다면: `INDEX(column1, column2)`

---

# 복합 인덱스 설계 기준

복합 인덱스를 만들 때 컬럼 순서와 쿼리 패턴을 고려해야 효율성을 극대화할 수 있다.

## 1. 카디널리티(Cardinality)가 높은 컬럼을 우선 배치
- **카디널리티란?**: 컬럼 내 고유 값의 개수. 카디널리티가 높을수록 인덱스의 선택성이 좋아져 검색 효율이 올라간다
- **예시**:
    - `birthday` (고유 값이 많음, 카디널리티 높음)
    - `gender` (값이 2~3개로 제한적, 카디널리티 낮음)
    - 추천 인덱스: `INDEX(birthday, gender)`
- **왜?**: 카디널리티가 높은 컬럼을 앞에 배치하면 데이터 필터링이 더 빨리 이루어져 후속 컬럼 검색 부하가 줄어든다

## 2. 쿼리 패턴 분석
쿼리의 조건과 연산자에 따라 인덱스 효율이 달라진다.

### (1) 등호(`=`)와 부등호(`>`, `<`)가 포함된 경우
- 등호 조건(`=`)이 사용되는 컬럼을 인덱스 앞쪽에 배치한다
- **예시**: `WHERE status = 'active' AND created_at > '2023-01-01'`
    - 추천 인덱스: `INDEX(status, created_at)`
- **왜?**: 등호 조건은 데이터를 더 명확히 필터링하므로 우선 적용하는 것이 효율적이다

### (2) LIKE 검색과 인덱스
- **B-Tree 인덱스**는 접두어 검색(`LIKE 'abc%'`)에만 효과적이다
    - 예: `WHERE name LIKE 'abc%'` → 인덱스 사용 가능
    - 예: `WHERE name LIKE '%abc'` 또는 `LIKE '%abc%'` → 인덱스 사용 불가, 풀 테이블 스캔 발생
- **MySQL에서의 대안**:
    - 풀텍스트 인덱스(Full-Text Index)를 사용하면 `LIKE '%abc%'` 같은 패턴도 빠르게 검색 가능하다
    - 단점: 풀텍스트 인덱스는 크기가 크고, 사용하려면 `MATCH ... AGAINST` 구문을 사용해야 한다
    - 예: `SELECT * FROM table WHERE MATCH(column) AGAINST('abc')`

---

# 추가 팁
- **인덱스 크기와 유지비용**: 인덱스는 검색 속도를 높이지만, 삽입/갱신/삭제 시 유지 비용이 발생한다
- **쿼리 실행 계획 확인**: `EXPLAIN` 명령어로 인덱스가 실제로 사용되는지 확인하며 최적화해야한다
